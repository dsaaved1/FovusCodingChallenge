{"ast":null,"code":"\"use strict\";\n\nvar browserGlobal = typeof window !== 'undefined' ? window : {};\nvar BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nvar local = typeof global !== 'undefined' ? global : this === undefined ? window : this;\n\n// node\nfunction useNextTick() {\n  return function () {\n    process.nextTick(flush);\n  };\n}\nfunction useMutationObserver() {\n  var iterations = 0;\n  var observer = new BrowserMutationObserver(flush);\n  var node = document.createTextNode('');\n  observer.observe(node, {\n    characterData: true\n  });\n  return function () {\n    node.data = iterations = ++iterations % 2;\n  };\n}\nfunction useSetTimeout() {\n  return function () {\n    local.setTimeout(flush, 1);\n  };\n}\nvar queue = [];\nfunction flush() {\n  for (var i = 0; i < queue.length; i++) {\n    var tuple = queue[i];\n    var callback = tuple[0],\n      arg = tuple[1];\n    callback(arg);\n  }\n  queue = [];\n}\nvar scheduleFlush;\n\n// Decide what async method to use to triggering processing of queued callbacks:\nif (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else {\n  scheduleFlush = useSetTimeout();\n}\nfunction asap(callback, arg) {\n  var length = queue.push([callback, arg]);\n  if (length === 1) {\n    // If length is 1, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    scheduleFlush();\n  }\n}\nexports.asap = asap;","map":{"version":3,"names":["browserGlobal","window","BrowserMutationObserver","MutationObserver","WebKitMutationObserver","local","global","undefined","useNextTick","process","nextTick","flush","useMutationObserver","iterations","observer","node","document","createTextNode","observe","characterData","data","useSetTimeout","setTimeout","queue","i","length","tuple","callback","arg","scheduleFlush","toString","call","asap","push","exports"],"sources":["/Users/diegosaavedra/Desktop/FovusCodingChallenge/frontend/node_modules/es6-promise/dist/commonjs/promise/asap.js"],"sourcesContent":["\"use strict\";\nvar browserGlobal = (typeof window !== 'undefined') ? window : {};\nvar BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nvar local = (typeof global !== 'undefined') ? global : (this === undefined? window:this);\n\n// node\nfunction useNextTick() {\n  return function() {\n    process.nextTick(flush);\n  };\n}\n\nfunction useMutationObserver() {\n  var iterations = 0;\n  var observer = new BrowserMutationObserver(flush);\n  var node = document.createTextNode('');\n  observer.observe(node, { characterData: true });\n\n  return function() {\n    node.data = (iterations = ++iterations % 2);\n  };\n}\n\nfunction useSetTimeout() {\n  return function() {\n    local.setTimeout(flush, 1);\n  };\n}\n\nvar queue = [];\nfunction flush() {\n  for (var i = 0; i < queue.length; i++) {\n    var tuple = queue[i];\n    var callback = tuple[0], arg = tuple[1];\n    callback(arg);\n  }\n  queue = [];\n}\n\nvar scheduleFlush;\n\n// Decide what async method to use to triggering processing of queued callbacks:\nif (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else {\n  scheduleFlush = useSetTimeout();\n}\n\nfunction asap(callback, arg) {\n  var length = queue.push([callback, arg]);\n  if (length === 1) {\n    // If length is 1, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    scheduleFlush();\n  }\n}\n\nexports.asap = asap;"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,aAAa,GAAI,OAAOC,MAAM,KAAK,WAAW,GAAIA,MAAM,GAAG,CAAC,CAAC;AACjE,IAAIC,uBAAuB,GAAGF,aAAa,CAACG,gBAAgB,IAAIH,aAAa,CAACI,sBAAsB;AACpG,IAAIC,KAAK,GAAI,OAAOC,MAAM,KAAK,WAAW,GAAIA,MAAM,GAAI,IAAI,KAAKC,SAAS,GAAEN,MAAM,GAAC,IAAK;;AAExF;AACA,SAASO,WAAWA,CAAA,EAAG;EACrB,OAAO,YAAW;IAChBC,OAAO,CAACC,QAAQ,CAACC,KAAK,CAAC;EACzB,CAAC;AACH;AAEA,SAASC,mBAAmBA,CAAA,EAAG;EAC7B,IAAIC,UAAU,GAAG,CAAC;EAClB,IAAIC,QAAQ,GAAG,IAAIZ,uBAAuB,CAACS,KAAK,CAAC;EACjD,IAAII,IAAI,GAAGC,QAAQ,CAACC,cAAc,CAAC,EAAE,CAAC;EACtCH,QAAQ,CAACI,OAAO,CAACH,IAAI,EAAE;IAAEI,aAAa,EAAE;EAAK,CAAC,CAAC;EAE/C,OAAO,YAAW;IAChBJ,IAAI,CAACK,IAAI,GAAIP,UAAU,GAAG,EAAEA,UAAU,GAAG,CAAE;EAC7C,CAAC;AACH;AAEA,SAASQ,aAAaA,CAAA,EAAG;EACvB,OAAO,YAAW;IAChBhB,KAAK,CAACiB,UAAU,CAACX,KAAK,EAAE,CAAC,CAAC;EAC5B,CAAC;AACH;AAEA,IAAIY,KAAK,GAAG,EAAE;AACd,SAASZ,KAAKA,CAAA,EAAG;EACf,KAAK,IAAIa,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,KAAK,CAACE,MAAM,EAAED,CAAC,EAAE,EAAE;IACrC,IAAIE,KAAK,GAAGH,KAAK,CAACC,CAAC,CAAC;IACpB,IAAIG,QAAQ,GAAGD,KAAK,CAAC,CAAC,CAAC;MAAEE,GAAG,GAAGF,KAAK,CAAC,CAAC,CAAC;IACvCC,QAAQ,CAACC,GAAG,CAAC;EACf;EACAL,KAAK,GAAG,EAAE;AACZ;AAEA,IAAIM,aAAa;;AAEjB;AACA,IAAI,OAAOpB,OAAO,KAAK,WAAW,IAAI,CAAC,CAAC,CAACqB,QAAQ,CAACC,IAAI,CAACtB,OAAO,CAAC,KAAK,kBAAkB,EAAE;EACtFoB,aAAa,GAAGrB,WAAW,CAAC,CAAC;AAC/B,CAAC,MAAM,IAAIN,uBAAuB,EAAE;EAClC2B,aAAa,GAAGjB,mBAAmB,CAAC,CAAC;AACvC,CAAC,MAAM;EACLiB,aAAa,GAAGR,aAAa,CAAC,CAAC;AACjC;AAEA,SAASW,IAAIA,CAACL,QAAQ,EAAEC,GAAG,EAAE;EAC3B,IAAIH,MAAM,GAAGF,KAAK,CAACU,IAAI,CAAC,CAACN,QAAQ,EAAEC,GAAG,CAAC,CAAC;EACxC,IAAIH,MAAM,KAAK,CAAC,EAAE;IAChB;IACA;IACA;IACAI,aAAa,CAAC,CAAC;EACjB;AACF;AAEAK,OAAO,CAACF,IAAI,GAAGA,IAAI","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}